---
title: "Seminarski"
output:
  word_document: default
  html_document: default
  pdf_document: default
date: "`r Sys.Date()`"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

  Za budućeg diplomiranog studenta, izbor univerziteta na koje će se prijaviti je zagonetka. Često se studenti pitaju da li je njihov profil dovoljno dobar za određeni univerzitet. Ovo pitanje smo rešili tako što smo izgradili sistem preporuka zasnovan na različitim algoritmima klasifikacije.. Podaci nisu bili lako dostupni, ali zahvaljujući devojci pod imenom Aditya Sureshkumar, sakupljeni su podaci sa *Edulik.com* i napravljen je skup podataka koji sadrži profile studenata koji su primljeni/odbijeni na 45 različitih univerziteta u SAD. Na osnovu ovog skupa podataka, obučeni su različiti modeli i predloženi su univerziteti koji maksimiziraju šanse da student dobije prijem sa tog univerziteta.
  U ovom radu analiziran je skup podataka „university recommendation” koji predstavlja profile studenata koji su primljeni/odbijeni na 45 različitih univerziteta u SAD-a.
  Ciljevi istraživanja su bili sledeći:
  
1. Da se izvrši adekvatan opis obeležja, i detaljna analiza uticaja/veza/zavisnosti između obeležja i u skupu podataka
2. Da se na principijalan način izvrši formiranje, odabir i tumačenje najadekvatnijeg modela mašinskog učenja za predviđanje prijema studenata na fakultetima u SAD-a.
3. Da se sirovi skup podataka dovede do nivoa kvaliteta koji omogućava dovoljno pouzdano statističko zaključivanje o vezama između obeležja. kao i formiranje adekvatnih modela mašinskog učenja za predviđanje prijema studenata na fakultetima u SAD-a.


# Učitavanje biblioteka

```{r}
library(tidyverse)
library(dplyr)
library(magrittr)
library(Amelia)
library(ggpubr)
library(Cairo)
library(broom)
library(randomForest)
library(rpart)
library(rpart.plot)

```

# Uvod

```{r}
fajl = read.csv("original_data.csv")
#View(fajl)
```

Skup podataka koji će biti obrađen dat je u CSV formatu, u fajlu *original_data.csv*. Nakon učitavanja podataka, funkcija **dim** daje informacije o dimenzijama okvira podataka. Vidi se da skup podataka sadrži 53644 redova i 26 kolona/obeležja. Funkcija **summary** daje detaljnu statistiku o svakoj koloni/obeležju to jest: maksimum, minimum, medijanu, broj nedostajućih vrednosti, prvi kvartil, treći kvartil.

```{r}
dim(fajl)
```

```{r}
summary(fajl)
```

Funkcijom **str** proveravamo kakva je struktura datih kolona/obeležja. Možemo videti da postoji 12 obeležja znakovnog tipa(chr) i 14 obeležja numeričkog tipa, a od toga su 11 obeležja tipa (int) i 3 obeležja tipa (num).

```{r}
str(fajl)
```

Obeležja i njihov opis koje sadrži okvir podataka *university recommendation*

* userName - Korisničko ime u edulik.com  
* major - Smer koji je korisnik pohadjao/pohadja   
* researchExp - Istraživačko iskustvo u mesecima 
* industryExp - Industrijsko iskustvo u mesecima 
* specialization - Namenjena specijalizacija za visoke studije
* toeflScore -TOEFL ( jedan od dva glavna testa znanja engleskog jezika prihvaćena na univerzitetima širom sveta, predstavlja skracenicu od recenice "the Test Of English as a Foreign Language" odnosno "Test engleskog kao stranog jezika ")
* program - Nameravani diplomski program
* department - Odeljenje u kojem je korisnik bio/je upisan
* toeflEssay - Ocena korisnickog eseja za test TOEFL.
* internExp - staž iskustvo u mesecima
* greV - predstavlja GRE-ov verbalni rezultat (GRE je standardizovani test koji postoji od 1936. godine i koji izračunava tri veoma važna parametra: verbalno i kvantitativno rezonovanje i analitičko pisanje. Ovo obeležje se odnosi na ocenu verbalnog rezonovanja)
* greQ - GRE kvantitativan rezultat (deo GRE testa koji se odnosi na znanje iz matematike)
* userProfileLink - Link do korisničkog profila na edulik.com
* journalPubs - broj publikacija časopisa
* greA - GRE AWA rezultat (deo GRE testa koji se odnosi na znanje iz analitičkog pisanja)
* termAndYear - Predviđeni termin pridruživanja. Npr.: jesen - 2022
* confPubs - broj publikacija na konferenciji
* ugCollege - koledži odnosno srednje škole iz koje đak dolazi.
* gmatA - rezulatat na GMAT AWA testu (test za koji se koristi za analiziranje obrazloženja datog argumenta i da napišete kritiku tog argumenta)
* cgpa - srednja prosečna ocena koja se koristi za procenu akademskog učinka
* gmatQ - rezulati na GMAT quant testu (test koji meri sposobnosti matematičkog zaključivanja, rešavanja kvantitaivnih problema i tumačenja grafičkih podatataka)
* cgpaScale - CGPA(Kumulativni prosek ocena) skala  za studentov prosek ocena
* topperCgpa - vrednost CGPA u najvisem delu rang liste
* gmatV - rezulati na GMAT verbal testu (test koji meri sposobnosti za čitanje i shvatanje napisanog materijala)
* univName - Naziv univerziteta za koji je student aplicirao
* admit - Rezultat aplikacije na fakultet(0/1 - odbijen/prihvaćen)



Moramo proveriti koliko svaka kolona ima nedostajućih vrednosti i došli smo do zaključka da obeležja: **gmatA**, **gmatQ**, **gmatV** imaju više od 99% nedostajućih vrednosti, i nemoguće je popuniti te nedostajuće vrednosti već je najbolje ukloniti ih. Razloh zašto većina studenata nemaju rezultate jeste jer *gmat* test nije značajan pri upisu na željene univerzitete, tako da većina studenata i nije radilo ove testove.

```{r}
(colMeans(is.na(fajl)))*100
```


```{r}
novi_univerziteti = subset(fajl, select = -c(gmatA, gmatQ, gmatV))
```

Analizirajući okvir podataka, primećeno je da obeležje **termAndYear** sadrži informaciju koje godine i kog semestra je predviđeni termin pridruživanja studenta željenom fakultetu u formatu *jesen - 2022*. 

```{r}
head(novi_univerziteti$termAndYear,n=50)  
```

Da bismo dobili tačnije informacije, kreiraćemo 2 nova obeležja, tako što ćemo trenutni razdvojiti po karakteru "-". Kreiraćemo obeležje **year** koje će sadržati godinu pridruživanja, i **term** koji će sadržati semestar pridruživanja. 

```{r}
novi_univerziteti$term = sapply(novi_univerziteti$termAndYear,
                                  FUN = function(x) unlist(strsplit(x, split = " - "))[1])

novi_univerziteti$year = sapply(novi_univerziteti$termAndYear,
                                  FUN = function(x) unlist(strsplit(x, split = " - "))[2])


```

```{r}
novi_univerziteti=subset(novi_univerziteti, select = -c(termAndYear))
```


Jedinstvene vrednosti novonastale kategorije *year*

```{r}
unique(novi_univerziteti$year)
```

Jedinstvene vrednosti novonastale kategorije *term*

```{r}
unique(novi_univerziteti$term)
```
  Potrebno je odrediti koliko sva obeležja karakternog tipa (*chr* tip) imaju jedninstvenih vrednosti kako bismo ih pretvorili u faktor obeležja (*fct* tip). Deo tih obeležja moguće je direktno preobraziti u faktor promenljive ukoliko nemaju preveliki broj jedinstvenih vrednosti, dok obeležja sa velikim brojem jedinstvenih vrednosti potrebno je dodatno analizirati.
  
```{r}
tempDF <- as.data.frame(lengths(lapply(fajl %>% select(where(is.character)),unique))) 
colnames(tempDF) = c("broj_jedinstvenih_vrednosti")

tempDF
```

Međutim pregledajući podatke uz pomoć funkcija *View* i *str* primetili smo da obeležje confPubs da uglavnom sadrži numeričke vrednosti, zato ćemo to sada detaljnije proveriti.

```{r}
xtabs(~novi_univerziteti$confPubs)
```

Kao što možemo primeti, većina podataka su numerička, dok karakterni primeri deluju kao greske odnosno izuzeci. Iako ćemo se kasnije detaljnije baviti izuzecima, radi lakseg daljeg rada, odmah ćemo ukloniti te uzorke.

```{r}
novi_univerziteti=novi_univerziteti[!grepl("Fall", novi_univerziteti$confPubs),]
```


Nakon pregleda jedinstvenih vrednosti za karakterna obeležja, zaključeno je da *program*, *toeflEssay*, *journalPubs*, *univName*, *term* i *year* ispunjavaju potreban kriterijum za transormisanje u kategorijsko obeležje.

```{r}
novi_univerziteti$program = as.factor(novi_univerziteti$program)
novi_univerziteti$toeflEssay = as.factor(novi_univerziteti$toeflEssay)
novi_univerziteti$journalPubs = as.factor(novi_univerziteti$journalPubs)
novi_univerziteti$univName = as.factor(novi_univerziteti$univName)
novi_univerziteti$term = as.factor(novi_univerziteti$term)
novi_univerziteti$year = as.factor(novi_univerziteti$year)

str(novi_univerziteti)
```


Takođe potrebno je odrediti i za sva obeležja numeričkog tipa (*int* i *num* tipovi) imaju jedninstvenih vrednosti kako bismo ih pretvorili u faktor obeležja (*fct* tip).


```{r}
tempDF <- as.data.frame(lengths(lapply(fajl %>% select(where(is.numeric)),unique))) 
colnames(tempDF) = c("broj_jedinstvenih_vrednosti")

tempDF
```

Nakon pregleda jedinstvenih vrednosti za numerička obeležja, zaključeno je da  *cgpaScale* i *admit* ispunjavaju potreban kriterijum za transormisanje u kategorijsko obeležje.


```{r}

novi_univerziteti$cgpaScale = as.factor(novi_univerziteti$cgpaScale)
novi_univerziteti$admit = as.factor(novi_univerziteti$admit)

str(novi_univerziteti)
```

Takođe ono što smo zaključili zahvaljući funkciji **str** jeste da nam obeležja *userName* i  *userProfileLink* neće biti korisna u daljem radu zato što samo predstavljaju nalog studenta na *edulik.com*, kao i sam link ka nalogu, zbog čega će navedena obeležja biti uklonjena i neće se koristiti u daljoj analizi. 

```{r}
novi_univerziteti = subset(novi_univerziteti, select = -c(userName, userProfileLink))
dim(novi_univerziteti)
```

# Redukovanje kategorija

  Znakovna obeležja *major*, *specialization*, *ugCollege* i *department*, odnosno obeležja sa velikim brojem jedinstvenih vrednosti, potrebno je redukovati putem funkcije **fct_lump** koja zadržava zadati broj kategorija, a ostale kategorije spaja u novu kategoriju. Nakon toga, iskoristićemo funkciju **fct_infreq** koja će sortirati kategorije obeležja prema broju pojavljivanja.


  Da bi se odredio broj kategorija koji bi trebalo zadržati, korišćena je grafička metoda *Cleveland tačkasti dijagram*, koja predstavlja alternativu za stubičaste dijagrame, ali njome dobijamo manju prenatrpanost na dijagramu. Posmatranjem dijagrama i korišćenjem heuristike vezanoj za određivanje broja klastera, možemo proceniti minimalnu dozvoljenu učestalost za kategorije posmatranog obeležja. One kategorije koje imaju učestalnost ispod dozvoljene potrebno je spojiti u jednu novu kategoriju.
  S obzirom da funkcija **fct_lump** zahteva kao ulazni parametar broj najčešćih kategorija koje treba zadržati, taj parametar je izračunat na osnovu minimalne učestalosti datog obeležja, i nazvan **prag**.

  Nakon što se prag izračuna, potrebno je proveriti da li na grafiku desno od izračunatog praga ne postoje prevelike varijacije u učestalnosti preostalih kategorija. Ukoliko ih nema, postojeći odnosno izračunati prag se zadržava. U suprotnom, potrebno je zadati novu minimalnu učestalost, i ponavlja heuristika za novi prag. Prag je na dijagramu predstavljen vertikalnom crvenom linijom.

```{r}

# Pomoćna metoda za zaokruživanje na gore za svrhu određivanja limita y-ose
round_up <- function(df, kol, base=1000){
vektor_kolona <- df %>% pull({{kol}})
maks = max(vektor_kolona)
return(base*ceiling(maks/base))
}

tempDF <- as_tibble(as.data.frame(table(novi_univerziteti$major))) %>%
arrange(desc(Freq)) %>%
mutate(rbr=seq_along(Var1)) %>% rename_with(~c("major","frekvencija","rbr"))
tempDF
yLim <- round_up(tempDF,frekvencija,500)
# Prag predstavlja broj kategorija koje će biti zadržane
# Sve kategorije ispod praga bi'e spojene u jednu novu kategoriju
prag <- tempDF %>% filter(frekvencija>400) %>% pull(rbr) %>% .[length(.)]
# Cleveland tačkasti dijagram za obeležje major
mojplot <- ggdotchart(tempDF, x = "rbr", y = "frekvencija", sorting = "descending")+
geom_vline(xintercept = prag, linetype = 2, color = "red")+
geom_hline(yintercept = 400, linetype = 2, color = "blue")+
theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size=8))+
scale_y_continuous(expand=c(0,0),breaks = seq(0, yLim, by=1000))+
scale_x_discrete(expand=c(0,0),breaks = seq(1, 100, by=2))+annotate(x=32,y=+Inf,
label=paste0("Prag=",prag,"\nza spajanje kategorija obeležja
major\n redje učestalih od 400"),vjust=2,geom="label")+
coord_cartesian(ylim = c(0,yLim),xlim = c(0,100))+
labs(x="Kategorija obeležja major (predstavljena rednim brojem u skladu sa
frekfencijom pojavljivanja)",
y="Frekfencija")+
theme(axis.text.x=element_text(size=7, angle=0,hjust=0.3,vjust=0.8, color="black"))
mojplot

# Združivanje retkih kategorija u novu kategoriju
novi_univerziteti <- novi_univerziteti %>% mutate(major = fct_lump(major, prag), major = fct_infreq(major))
```


```{r}

tempDF <- as_tibble(as.data.frame(table(novi_univerziteti$department))) %>%
arrange(desc(Freq)) %>%
mutate(rbr=seq_along(Var1)) %>% rename_with(~c("department","frekvencija","rbr"))
tempDF
yLim <- round_up(tempDF,frekvencija,500)
# Prag predstavlja broj kategorija koje će biti zadržane
# Sve kategorije ispod praga biće spojene u jednu novu kategoriju
prag <- tempDF %>% filter(frekvencija>400) %>% pull(rbr) %>% .[length(.)]
# Cleveland tačkasti dijagram za obeležje department
mojplot <- ggdotchart(tempDF, x = "rbr", y = "frekvencija", sorting = "descending")+
geom_vline(xintercept = prag, linetype = 2, color = "red")+
geom_hline(yintercept = 400, linetype = 2, color = "blue")+
theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size=8))+
scale_y_continuous(expand=c(0,0),breaks = seq(0, yLim, by=1000))+
scale_x_discrete(expand=c(0,0),breaks = seq(1, 100, by=2))+annotate(x=32,y=+Inf,
label=paste0("Prag=",prag,"\nza spajanje kategorija obeležja
department\n redje učestalih od 400"),vjust=2,geom="label")+
coord_cartesian(ylim = c(0,yLim),xlim = c(0,100))+
labs(x="Kategorija obeležja department (predstavljena rednim brojem u skladu sa
frekfencijom pojavljivanja)",
y="Frekfencija")+
theme(axis.text.x=element_text(size=7, angle=0,hjust=0.3,vjust=0.8, color="black"))
mojplot

# Združivanje retkih kategorija u novu kategoriju
novi_univerziteti <- novi_univerziteti %>% mutate(department = fct_lump(department, prag), department = fct_infreq(department))
```

```{r}

tempDF <- as_tibble(as.data.frame(table(novi_univerziteti$specialization))) %>%
arrange(desc(Freq)) %>%
mutate(rbr=seq_along(Var1)) %>% rename_with(~c("specialization","frekvencija","rbr"))
tempDF
yLim <- round_up(tempDF,frekvencija,500)
# Prag predstavlja broj kategorija koje će biti zadržane
# Sve kategorije ispod praga biće spojene u jednu novu kategoriju
prag <- tempDF %>% filter(frekvencija>400) %>% pull(rbr) %>% .[length(.)]
# Cleveland tačkasti dijagram za obeležje specialization
mojplot <- ggdotchart(tempDF, x = "rbr", y = "frekvencija", sorting = "descending")+
geom_vline(xintercept = prag, linetype = 2, color = "red")+
geom_hline(yintercept = 400, linetype = 2, color = "blue")+
theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size=8))+
scale_y_continuous(expand=c(0,0),breaks = seq(0, yLim, by=1000))+
scale_x_discrete(expand=c(0,0),breaks = seq(1, 100, by=2))+annotate(x=32,y=+Inf,
label=paste0("Prag=",prag,"\nza spajanje kategorija obeležja
specialization\n redje učestalih od 400"),vjust=2,geom="label")+
coord_cartesian(ylim = c(0,yLim),xlim = c(0,100))+
labs(x="Kategorija obeležja specialization (predstavljena rednim brojem u skladu sa
frekfencijom pojavljivanja)",
y="Frekfencija")+
theme(axis.text.x=element_text(size=7, angle=0,hjust=0.3,vjust=0.8, color="black"))
mojplot

# Združivanje retkih kategorija u novu kategoriju
novi_univerziteti <- novi_univerziteti %>% mutate(specialization = fct_lump(specialization, prag), specialization = fct_infreq(specialization))
```

```{r}

tempDF <- as_tibble(as.data.frame(table(novi_univerziteti$ugCollege))) %>%
arrange(desc(Freq)) %>%
mutate(rbr=seq_along(Var1)) %>% rename_with(~c("ugCollege","frekvencija","rbr"))
tempDF
yLim <- round_up(tempDF,frekvencija,500)
# Prag predstavlja broj kategorija koje će biti zadržane
# Sve kategorije ispod praga biće spojene u jednu novu kategoriju
prag <- tempDF %>% filter(frekvencija>300) %>% pull(rbr) %>% .[length(.)]
# Cleveland tačkasti dijagram za obeležje ugCollege
mojplot <- ggdotchart(tempDF, x = "rbr", y = "frekvencija", sorting = "descending")+
geom_vline(xintercept = prag, linetype = 2, color = "red")+
geom_hline(yintercept = 300, linetype = 2, color = "blue")+
theme(axis.text.x = element_text(angle = 0, vjust = 0.5, hjust=1,size=8))+
scale_y_continuous(expand=c(0,0),breaks = seq(0, yLim, by=1000))+
scale_x_discrete(expand=c(0,0),breaks = seq(1, 100, by=2))+annotate(x=32,y=+Inf,
label=paste0("Prag=",prag,"\nza spajanje kategorija obeležja
ugCollege\n redje učestalih od 300"),vjust=2,geom="label")+
coord_cartesian(ylim = c(0,yLim),xlim = c(0,100))+
labs(x="Kategorija obeležja ugCollege (predstavljena rednim brojem u skladu sa
frekfencijom pojavljivanja)",
y="Frekfencija")+
theme(axis.text.x=element_text(size=7, angle=0,hjust=0.3,vjust=0.8, color="black"))
mojplot

# Združivanje retkih kategorija u novu kategoriju
novi_univerziteti <- novi_univerziteti %>% mutate(ugCollege = fct_lump(ugCollege, prag), ugCollege = fct_infreq(ugCollege))
```






# Nedostajuće vrednosti


```{r graph}
missmap(obj = novi_univerziteti, main = "university recommendation", legend = FALSE)
(colMeans(is.na(novi_univerziteti)))*100
```

## Specialization

<br><br>

```{r}
xtabs(~novi_univerziteti$specialization)
length(which(is.na(novi_univerziteti$specialization)))
```

Obeležje specialization sadrži samo 3 reda sa nedostajućim vrednostima, što predstavlja samo 0.005592424 procenata našeg okvira podataka, tako da te uzorke možemo slobodno obrisati.

```{r}
novi_univerziteti <- novi_univerziteti[-which(is.na(novi_univerziteti$specialization)), ] #funkcija za brisanje uzoraka
```

Posmatranjem nivoa datog obeležja, primetili smo da više od trećine podataka imaju vrednost praznog stringa (""). Međutim, to nećemo gledati kao NA vrednosti, zato što nedostatak tih vrednosti u stvari predstavlja da dati studenti nemaju namenjenu specijalizaciju za visoke studije, što je sasvim legitimna stvar.

Jedino radi boljeg razumevanja te uzorke ćemo preimenovati u **No specialization**, ali da bismo to uradili vratićemo na trenutak obeležje u karakterni tip.


```{r}

novi_univerziteti$specialization=as.character(novi_univerziteti$specialization)

novi_univerziteti$specialization[which(novi_univerziteti$specialization=="")]="No specialization"

novi_univerziteti$specialization=as.factor(novi_univerziteti$specialization)

```


## ToeflEssay

<br><br>

```{r}
length(which(novi_univerziteti$toeflEssay==""))/dim(novi_univerziteti)[1]*100
```


Obeležje toeflEssay nema nedostajuće vrednosti, međutim, analizirajući podatke zaključili smo da čak 77 posto uzoraka imaju vrednost praznog stringa, odnosno (""). Međutim prikupljajući domensko znanje, saznali smo da celokupni TOEFL test se sastoji od 4 oblasti. Čitanja engleskog jezika, slušanja, pričanja i pisanja. Oblast vezana za pisanje može se polagati na dva načina. Jedan predstavlja čitanje kratkog odlomka i slušanja kratkog predavanja, a zatim se treba napisati odgovor na ono što je pročitano i saslušano. Drugi način predstavlja pisanje eseja na osnovu ličnog iskustva ili mišljenja kao odgovor na temu pisanja, čiji rezultati upravo predstavljaju dato obeležje. To znači da je u redu da korisnici nemaju vrednost za ovo obeležje, jer to znači su oblast pisanja polagali na prvi način.

<br>
Radi lakšeg manipulisanja, prazne string vrednosti konvertovaćemo u 0.


```{r}


novi_univerziteti$toeflEssay[novi_univerziteti$toeflEssay==""]=0 

length(which(novi_univerziteti$toeflEssay==""))

```



## ToeflScore  

<br><br>

Kod ovog obeležja, nedostajuće vrednosti su sasvim slučajne, i nema načina detaljnije pretpostaviti nedostajuće vrednosti za svaki uzorak. Zbog toga ćemo nedostajuće vrednosti popuniti medijanom ili prosečnom vrednošću obeležja, a normalnost podataka ćemo zaključiti Shapiro-Wilk" testom. S obzirom da je nemoguće ovu metodu primeniti nad velikim brojem uzoraka, primenićemo sledeći postupak. Hiljadu puta ćemo uzorkovati bez ponavljanja 3000 nasumičnih opservacija iz celog okvira podataka. Nad svakim od hiljadu uzoraka biće primenjen Shapiro-Wilk" test. Prosečna p-vrednost svih 1000 testova biće izabrana kao merodavna za statističko zaključivanje.


```{r}
p_vrednosti = replicate(1000, shapiro.test(sample(novi_univerziteti$toeflScore,3000))$p.val) 
prosecna_pvrednost = mean(p_vrednosti) 
prosecna_pvrednost 
```

Nakon uspešno izvršenog eksperimenta, s obzirom da je prosečna p vrednost znatno manja od 0.05, to nam govori da nam raspodela podataka nije normalna, i da treba koristiti medijanu. Tako da ćemo sve nedostajuće vrednosti popuniti medijanom obeležja.

```{r}
novi_univerziteti$toeflScore[is.na(novi_univerziteti$toeflScore)]=median(novi_univerziteti$toeflScore,na.rm = TRUE) #funkcija za popunjavanje medijanom
length(which(is.na(novi_univerziteti$toeflScore))) #provera 
```

## GreV, greQ i greA

<br><br>

GRE je standardizovani test koji postoji od 1936. godine i koji izračunava tri veoma važna parametra: verbalno i kvantitativno rezonovanje i analitičko pisanje. Obeležje greV jeste ocena za verbalno rezonovanje, greQ za kvantitavino, dok greA obeležava analitičko pisanje.

<br>

S obzirom da imamo dosta uzoraka gde postoji nedostajuća vrednost samo za jedno od obeležja, proverićemo da li postoji korelacija između ova tri obeležja. 


```{r}

pairs(novi_univerziteti[c(10,11,13)])

```

Na osnovu plotova možemo jasno zaključiti da ne postoji nikakva korelacija između greA i druga dva obeležja, dok na osnovu slike nismo sto posto sigurni da li postoji korelacija između obeležja greV i greQ, tako da ćemo funkcijom koja izračunava korelaciju zaključiti da li korelacija postoji.

<br>

Za početak moramo pripremiti podatke, odnosno da izbacimo sve nedostajuće vrednosti da bismo mogli da izračunamo korelaciju. Pošto broj uzoraka mora biti identičan za oba obeležja, uporedićemo onoliko uzoraka koliko kraće obeležje ima uzoraka.


```{r}
greV= na.omit(novi_univerziteti$greV) #izbacivanje NA vrednosti
greQ= na.omit(novi_univerziteti$greQ)

l1= length(greV) #greV ima manje uzoraka nakon izbacivanja NA vrednosti
l2= length(greQ)

cor(greV[1:l1],greQ[1:l1])
```
Nakon određivanja korelacije, rezultat pokazuje da ne postoji korelacija između ova dva obeležja. To znači da nikako na osnovu jednog obeležja ne možemo tačnije pretpostaviti vrednost drugog obeležja. 

```{r}

length(which(is.na(novi_univerziteti$greV)))
length(which(is.na(novi_univerziteti$greQ)))
length(which(is.na(novi_univerziteti$greA)))

```
S obzirom da broj uzoraka sa nedostajućim vrednostima nije mali, nećemo ih obrisati, jer nam mogu biti značajni u daljoj analizi, već ćemo ih popuniti na osnovu medijane ili prosečne vrednosti svih uzoraka za to obeležje, a to ćemo zaključiti na osnovu Shapiro-Wilk" testa. Postupak će biti sličan kao za jedno od prethodnih obeležja, hiljadu puta ćemo uzorkovati bez ponavljanja 3000 nasumičnih opservacija iz celog okvira podataka. Nad svakim od hiljadu uzoraka biće primenjen Shapiro-Wilk" test. Prosečna p-vrednost svih 1000 testova biće izabrana kao merodavna za statističko zaključivanje.


```{r}
p_vrednosti = replicate(1000, shapiro.test(sample(novi_univerziteti$greV,3000))$p.val) 
prosecna_pvrednost = mean(p_vrednosti) 
prosecna_pvrednost 


p_vrednosti = replicate(1000, shapiro.test(sample(novi_univerziteti$greQ,3000))$p.val) 
prosecna_pvrednost = mean(p_vrednosti) 
prosecna_pvrednost 


p_vrednosti = replicate(1000, shapiro.test(sample(novi_univerziteti$greA,3000))$p.val) 
prosecna_pvrednost = mean(p_vrednosti) 
prosecna_pvrednost 


```
S obzirom da je kod sva tri obeležja prosečna p vrednost znatno manja od 0.05, to nam govori da nam raspodela podataka nije normalna, i da treba koristiti medijanu. Tako da ćemo sve nedostajuće vrednosti popuniti medijanom obeležja.

```{r}
novi_univerziteti$greQ[is.na(novi_univerziteti$greQ)]=median(novi_univerziteti$greQ,na.rm = TRUE) #funkcija za popunjavanje medijanom
length(which(is.na(novi_univerziteti$greQ))) #provera za greQ

novi_univerziteti$greV[is.na(novi_univerziteti$greV)]=median(novi_univerziteti$greV,na.rm = TRUE) #funkcija za popunjavanje medijanom
length(which(is.na(novi_univerziteti$greV))) #provera za greV

novi_univerziteti$greA[is.na(novi_univerziteti$greA)]=median(novi_univerziteti$greA,na.rm = TRUE) #funkcija za popunjavanje medijanom
length(which(is.na(novi_univerziteti$greA))) #provera za greA



```

## Term i year

<br><br>

S obzirom da nema previše nedostajućih vrednosti iz ovih obeležja, a ne postoji dobar način za njihovo popunjavanje, obrisaćemo sve uzorke koje sadrže NA vrednosti iz ovog obeležja.


```{r}

novi_univerziteti= na.omit(novi_univerziteti)


```


# Izuzeci

Veoma je važno detektovati i otkloniti izuzetke kako bismo napravili što bolji model i kako bismo smanjili grešku.

## toeflScore

```{r}
ggplot(novi_univerziteti, aes(x = toeflScore, y = major)) + geom_boxplot(outlier.colour = "red") + labs(title = "Ocena na TOEFL testu na osnovu smera studija",
     x = "Ocena na TOEFL testu",
     y = "Smer")
```

```{r}
xtabs(~novi_univerziteti$toeflScore)
```



Sa grafika odnosa ocene na TOEFL testu i smera studija vidimo da ne postoji značajna razlika u oceni na TOEFL testu po smerovima studija. Kao što možemo videti, postoji veliki broj izuzetaka, međutim od toga nisu zaista sve izuzeci, ali nam je tako grafikom predstavljeno jer 80 posto podataka u opsegu između 91 i 117 poena. Po literaturi, broj poena na ovom testu može biti između 0 i 120 poena, tako da ćemo sve ostale uzorke odbaciti.

```{r}

novi_univerziteti = novi_univerziteti[which(novi_univerziteti$toeflScore>=0 & novi_univerziteti$toeflScore<=120),]

ggplot(novi_univerziteti, aes(x = toeflScore )) + geom_boxplot(outlier.colour = "red") + labs(title = "Ocena na TOEFL testu",
     x = "Ocena na TOEFL testu",
     y = "")
```
## researchExp

```{r}
ggplot(novi_univerziteti, aes(x = researchExp, y = program)) + geom_boxplot(outlier.colour = "red") + labs(title = "Istraživačko iskustvo u odnosu na program studija",
     x = "Istraživačko iskustvo",
     y = "Program studija")
```
Sa grafika odnosa istraživačkog iskustva i programa studija vidimo da ne postoji značajna razlika u istraživačkom iskustvu po programu studija. Ono što možemo zaključiti na osnovu grafika jeste da veliki broj uzoraka nemaju istraživačko iskustvo, i zato sve one osobe koje ga poseduju smatraju se izuzecima. Međutim mi te vrednosti nećemo ukloniti, jer u tom slučaju u našem okviru podataka imali bi samo one uzorke bez istraživačkog iskustva i samim tim ni to obeležje ne bi predstavljalo nikakav validan parametar za kasnije kreiranje modela.


Prvo ćemo proveriti koje sve jedinstvene vrednosti posedujemo, i u kom broju.

```{r}
xtabs(~novi_univerziteti$researchExp)

length(unique(novi_univerziteti$researchExp))


length(which(novi_univerziteti$researchExp==0))/dim(novi_univerziteti)[1]*100

```
Primećujemo da postoje 32 jedinstvene vrednosti, međutim čak 97% uzoraka nemaju istaživačko iskustvo. Zbog toga, sve ostale osobe koje imaju istraživačko iskustvo grupisaćemo u jednu celinu, i dato obeležje ćemo podeliti u 2 kategorije:
1. Osobe bez istraživačkog iskustva.
2. Osobe sa istraživačkim iskustvom.





```{r}
novi_univerziteti$researchExp = as.numeric(as.character(novi_univerziteti$researchExp))
novi_univerziteti$researchExp[novi_univerziteti$researchExp > 0] = 1
unique(novi_univerziteti$researchExp)
novi_univerziteti$researchExp = factor(novi_univerziteti$researchExp,
                                       levels = c(0,1), labels = c("Bez iskustva","Sa iskustvom"))
#novi_univerziteti$researchExp[is.na(novi_univerziteti$researchExp)] = 0 cemu ovo

novi_univerziteti$researchExp=as.factor(novi_univerziteti$researchExp)

ggplot(novi_univerziteti) + geom_bar(aes(x = researchExp))
```

## greV, greQ, greA


```{r}
ggplot(novi_univerziteti, aes(x = greV)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE-ov verbalni rezultat",
       x = "greV",
       y = "")
ggplot(novi_univerziteti, aes(x = greQ)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE kvantitativni rezultat",
       x = "greQ",
       y = "")
ggplot(novi_univerziteti, aes(x = greA)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE analitičko pisanje",
       x = "greA",
       y = "")

```

Što se tiče verbalnih i kvantitativnih rezultata GRE testa, današnja vrednost je u opsegu od 0 do 170 poena. Međutim, do 2011. godine, najveći mogući rezultat za ova dva testa iznosio je 800 poena, a uzorci iz našeg okvira podataka pripadaju tom periodu, tako da će izuzeci za ovo obeležje biti sve vrednosti van pomenutog opsega. 

```{r}
novi_univerziteti=novi_univerziteti[which(novi_univerziteti$greV>=0 & novi_univerziteti$greV<=800),]

novi_univerziteti=novi_univerziteti[which(novi_univerziteti$greQ>=0 & novi_univerziteti$greQ<=800),]

```

Sada data obeležja izgledaju ovako.


```{r}

ggplot(novi_univerziteti, aes(x = greV)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE-ov verbalni rezultat",
       x = "greV",
       y = "")
ggplot(novi_univerziteti, aes(x = greQ)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE kvantitativni rezultat",
       x = "greQ",
       y = "")
```

Što se tiče GRE testa za analitičko pisanje, opseg poena se nije menjao i maksimalni broj poena je i dalje 6. Tako da sve vrednosti veće od te predstavljaju izuzetke i biće uklonjeni.


```{r}

novi_univerziteti=novi_univerziteti[which(novi_univerziteti$greA>=0 & novi_univerziteti$greA<=6),]

```

Sada dato obeležje ima drugačiji izgled.

```{r}
ggplot(novi_univerziteti, aes(x = greA)) + geom_boxplot(outlier.colour = "red") + 
  labs(title = "GRE analitičko pisanje",
       x = "greA",
       y = "")
```



## internExp

```{r}
ggplot(novi_univerziteti) + geom_boxplot( aes(x = internExp),outlier.colour = "red") + labs(title = "Staž iskustvo u mesecima",
     x = "Staž iskustvo",
     y = "")
```
Na osnovu grafika kod iskustva u stažu, možemo primetiti istu stvar kao kod obeležja koje predstavlja istraživačko iskustvo, a to je da veliki broj uzoraka nemaju staža, i zato sve one osobe koje ga poseduju smatraju se izuzecima. Međutim mi te vrednosti nećemo ukloniti, jer u tom slučaju u našem okviru podataka imali bi samo one uzorke bez istraživačkog iskustva i samim tim ni to obeležje ne bi predstavljalo nikakav validan parametar za kasnije kreiranje modela.

Prvo ćemo proveriti koje sve jedinstvene vrednosti posedujemo, i u kom broju.

```{r}
xtabs(~novi_univerziteti$internExp)

length(unique(novi_univerziteti$internExp))


length(which(novi_univerziteti$internExp==0))/dim(novi_univerziteti)[1]*100

```
Primećujemo da postoje 26 jedinstvenih vrednosti, međutim čak 91% uzoraka nemaju staž iskustvo. Zbog toga, sve ostale osobe koje imaju iskustvo staža grupisaćemo u jednu celinu, i dato obeležje ćemo podeliti u 2 kategorije:
1. Osobe bez staža
2. Osobe sa stažom.


```{r}
novi_univerziteti$internExp = as.numeric(as.character(novi_univerziteti$internExp))
novi_univerziteti$internExp[novi_univerziteti$internExp > 0] = 1
unique(novi_univerziteti$internExp)
novi_univerziteti$internExp = factor(novi_univerziteti$internExp,
                                       levels = c(0,1), labels = c("Bez staža","Sa stažom"))
#novi_univerziteti$internExp[is.na(novi_univerziteti$internExp)] = 0

novi_univerziteti$internExp=as.factor(novi_univerziteti$internExp)

ggplot(novi_univerziteti) + geom_bar(aes(x = internExp))
```


## cgpa

```{r}
ggplot(novi_univerziteti) + geom_boxplot( aes(x = cgpa ),outlier.colour = "red") + labs(title = "Srednja prosečna ocena za procenu akademskog učinka",
     x = "Srednja prosečna ocena",
     y = "")
```

Primećujemo da postoji veliki izuzetak koji ćemo ukloniti.


```{r}
outlajeri = boxplot(novi_univerziteti$cgpa, plot = FALSE)$out

novi_univerziteti = novi_univerziteti[-which(novi_univerziteti$cgpa %in% outlajeri),]
ggplot(novi_univerziteti, aes(x = cgpa )) + geom_boxplot(outlier.colour = "red") + labs(title = "Srednja prosečna ocena za procenu akademskog učinka",
     x = "Srednja prosečna ocena",
     y = "")
```


## industryExp

```{r}
ggplot(novi_univerziteti) + geom_boxplot( aes(x = industryExp ),outlier.colour = "red") + labs(title = "Industrijsko iskustvo u mesecima",
     x = "Industrijsko iskustvo",
     y = "")
```


Ni ovo obeležje koje predstavlja iskustvo ne razlikuje se sa dosadašnjim. Međutim, ovde već na osnovu grafika možemo zaključiti da postoje veliki izuzeci koje bi trebalo ukloniti, a to su uzorci čiji je staž preko 110 nedelja.

```{r}
novi_univerziteti=novi_univerziteti[-which(novi_univerziteti$industryExp>110),]
```

Preostale podatke ćemo obraditi po istom principu.


```{r}
xtabs(~novi_univerziteti$industryExp)

length(unique(novi_univerziteti$industryExp))


length(which(novi_univerziteti$industryExp==0))/dim(novi_univerziteti)[1]*100

```
Primećujemo da ovde ipak postoji čak 92 jedinstvene vrednosti, međutim ponovo više od 86% uzoraka nemaju industrijsko iskustvo. Zbog toga, sve ostale osobe koje imaju iskustvo staža grupisaćemo u jednu celinu, i dato obeležje ćemo podeliti u 2 kategorije:
1. Sa industrijskim iskustvom.
2. Bez industrijskog iskustva.


```{r}
novi_univerziteti$industryExp = as.numeric(as.character(novi_univerziteti$industryExp))
novi_univerziteti$industryExp[novi_univerziteti$industryExp > 0] = 1
#unique(novi_univerziteti$industryExp)
novi_univerziteti$industryExp = factor(novi_univerziteti$industryExp,
                                       levels = c(0,1), labels = c("Bez iskustva","Sa iskustvom"))
#novi_univerziteti$industryExp[is.na(novi_univerziteti$industryExp)] = 0

novi_univerziteti$industryExp=as.factor(novi_univerziteti$industryExp)

ggplot(novi_univerziteti) + geom_bar(aes(x = industryExp))
```



## year


```{r}
ggplot(novi_univerziteti, aes(y = year)) + geom_bar() + labs(title = "Godine kada su studenti konkurisali", x = "Godina", y = "Broj jedinstvenih vrednosti")
```
Na osnovu barplota iznad vidimo da obeležje *year*(godine kada su studenti konkurisali za upis na fakultet) sadrži neke vrednosti koje su nelogične kada su u pitanju godine. Na osnovu logike isključićemo sve vrednosti koje su manje od 2006 i sve vrednosti koje su veće od 2016.

```{r}

novi_univerziteti = novi_univerziteti[-which(novi_univerziteti$year != 2006 & novi_univerziteti$year != 2007 & novi_univerziteti$year != 2008 & novi_univerziteti$year != 2009 
                                                    & novi_univerziteti$year != 2010 & novi_univerziteti$year != 2011 & novi_univerziteti$year != 2012 & novi_univerziteti$year != 2013 
                                                    & novi_univerziteti$year != 2014 & novi_univerziteti$year != 2015 & novi_univerziteti$year != 2016),]
ggplot(novi_univerziteti, aes(x = year)) + geom_bar() + labs(title = "Godine kada su studenti konkurisali", x = "Godina", y = "Broj jedinstvenih vrednosti")

novi_univerziteti$year = droplevels(novi_univerziteti$year)
```


## confPubs


```{r}
ggplot(novi_univerziteti) + geom_bar(aes(x = confPubs))
```


```{r}

xtabs(~novi_univerziteti$confPubs)

length(unique(novi_univerziteti$confPubs))


length(which(novi_univerziteti$confPubs==0))/dim(novi_univerziteti)[1]*100
```
I ovde možemo zaključiti da većina nije imalo publikacije, tako da ćemo i ovo obeležje konvertovati u faktor promenljivu sa 2 kategorije:

1. Bez publikacije
2. Sa publikacijom


```{r}
novi_univerziteti$confPubs = as.numeric(as.character(novi_univerziteti$confPubs))
novi_univerziteti$confPubs[novi_univerziteti$confPubs > 0] = 1
#unique(novi_univerziteti$confPubs)
novi_univerziteti$confPubs = factor(novi_univerziteti$confPubs,
                                       levels = c(0,1), labels = c("Bez publikacije","Sa publikacijom"))
#novi_univerziteti$confPubs[is.na(novi_univerziteti$confPubs)] = 0

novi_univerziteti$confPubs=as.factor(novi_univerziteti$confPubs)

ggplot(novi_univerziteti) + geom_bar(aes(x = confPubs))
```



## journalPubs

```{r}
ggplot(novi_univerziteti) + geom_bar(aes(x = journalPubs))
```
Potpuno istu stvar uočavamo i sa publikacijom časopisa.



```{r}

xtabs(~novi_univerziteti$journalPubs)

length(unique(novi_univerziteti$journalPubs))


length(which(novi_univerziteti$journalPubs==0))/dim(novi_univerziteti)[1]*100
```
Kategorije:

1. Bez publikacije
2. Sa publikacijom


```{r}
novi_univerziteti$journalPubs = as.numeric(as.character(novi_univerziteti$journalPubs))
novi_univerziteti$journalPubs[novi_univerziteti$journalPubs > 0] = 1
#unique(novi_univerziteti$journalPubs)
novi_univerziteti$journalPubs = factor(novi_univerziteti$journalPubs,
                                       levels = c(0,1), labels = c("Bez publikacije","Sa publikacijom"))
#novi_univerziteti$journalPubs[is.na(novi_univerziteti$journalPubs)] = 0

novi_univerziteti$journalPubs=as.factor(novi_univerziteti$journalPubs)

ggplot(novi_univerziteti) + geom_bar(aes(x = journalPubs))
```



# EDA - Exploratory Data Analysis

Da bismo napravili dobar model moramo da vidimo u kakvoj su zavisnosti data obeležja sa obeležjem *admit*(student je prihvaćen/odbijen).

## Analiza kategorijskih podataka naspram numeričkih

Kada bismo samo upoređivali obeležja admit u odnosu na druga numerička obeležja, ne bi primetili nikakvu povezanost između njih, već bi za primljene i odbijene đake grafik izgledao identično. Zbog toga ćemo pri upoređivanju obeležja admit naspram numeričkih obeležja, upoređivaćemo i sa obeležjem univName, zato što jedino na taj način možemo zaključiti koliko neka numerička promenljiva utiče na upis u zavisnosti od fakulteta.


```{r}
length(unique(novi_univerziteti$univName))
```

S obzirom da je broj fakulteta 54, prikaz podataka u odnosu na svaki fakultet na jednom grafiku bilo bi previše nepregledno. Zbog toga ćemo morati naš okvir podataka podeliti u 6 manjih okvira, tako što će svaki okvir sadržati samo one uzorke koje za obeležje univName imaju neki od 9 odabranih univerziteta.


```{r}

names=unique(novi_univerziteti$univName)


univ1=names[1:9]
univ2=names[10:18]
univ3=names[19:27]
univ4=names[28:36]
univ5=names[37:45]
univ6=names[46:54]


okvir1=novi_univerziteti[novi_univerziteti$univName %in%  univ1,]
okvir2=novi_univerziteti[novi_univerziteti$univName %in%  univ2,]
okvir3=novi_univerziteti[novi_univerziteti$univName %in%  univ3,]
okvir4=novi_univerziteti[novi_univerziteti$univName %in%  univ4,]
okvir5=novi_univerziteti[novi_univerziteti$univName %in%  univ5,]
okvir6=novi_univerziteti[novi_univerziteti$univName %in%  univ6,]


```



### greV i admit


```{r}


ggplot(okvir1, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



```



```{r}
#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(greV, "pnorm", mean=mean(greV, na.rm = T), 
sd=sd(greV, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```
  
  Na osnovu grafika iznad vidimo da rezultati greV testa utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).

### greQ i admit




```{r}


ggplot(okvir1, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=greQ)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=greQ)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



```


```{r}
#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(greQ, "pnorm", mean=mean(greQ, na.rm = T), 
sd=sd(greQ, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```


Na osnovu grafika iznad vidimo da rezultati greV testa utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).

### greA i admit



```{r}


ggplot(okvir1, aes(x=admit,y=greV)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=greA)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=greA)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=greV)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=greA)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=greA)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=greA)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=greA)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=greA)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=greA)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=greA)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=greA)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



```


```{r}

#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(greA, "pnorm", mean=mean(greA, na.rm = T), 
sd=sd(greA, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```


Na osnovu grafika iznad vidimo da rezultati greV testa utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).


### toeflScore i admit

```{r}
ggplot(okvir1, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=toeflScore)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=toeflScore)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

```


```{r}

#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(toeflScore, "pnorm", mean=mean(toeflScore, na.rm = T), 
sd=sd(toeflScore, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```

Na osnovu grafika iznad vidimo da toefl skor utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).


### topperCgpa i admit



```{r}


ggplot(okvir1, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=topperCgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=topperCgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



```


```{r}
#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(topperCgpa, "pnorm", mean=mean(topperCgpa, na.rm = T), 
sd=sd(topperCgpa, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```


Na osnovu grafika iznad vidimo da srednja prosečna ocena u najvišem delu rang liste utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).


### cgpa i admit

```{r}
ggplot(okvir1, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir1, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir2, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir2, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir3, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir3, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())




ggplot(okvir4, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir4, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())



ggplot(okvir5, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir5, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

 

ggplot(okvir6, aes(x=admit,y=cgpa)) +
geom_boxplot(alpha=1) + theme_bw()  + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

ggplot(okvir6, aes(x=admit,y=cgpa)) + 
geom_violin(alpha=1) + 
theme_bw() + ylab(NULL)+theme(axis.text.y = element_blank(),axis.ticks.y = element_blank()) + facet_wrap(~ univName, nrow = 4,labeller = label_wrap_gen())

```

```{r}
#K-S test normalnosti 
novi_univerziteti %>% group_by(admit) %>% 
summarise(izlaz = list(ks.test(cgpa, "pnorm", mean=mean(cgpa, na.rm = T), 
sd=sd(cgpa, na.rm = T)) %>% tidy), .groups = 'drop') %>% unnest(c(izlaz))
```

Na osnovu grafika iznad vidimo da cgpa utiče na to da li je osoba primljena na fakultet ili nije, ali zavisi od fakulteta. Testiranjem normalnosti Kolmogorov-Smirnov testom pokazano je da ne postoji normalnost unutar obe grupe obeležja (*p* = 0.0 < *α*=0.05, *p* = 0.0 <  *α*=0.05).

### cgpa, greA i admit

```{r}
ggplot(novi_univerziteti, aes(x = cgpa, y=greA)) +
 geom_point(aes(colour=admit)) +
 xlab("Srednja prosečna ocena") +
 ylab("Rezultat na GRE AWA testu")
```
  Na osnovu grafika iznad vidimo da ukoliko je student imao veću prosečnu ocenu i ukoliko je imao bolji rezultat na greA testu onda je veća verovatnoća da je primljen na fakultet.

## Analiza kategorijskih podataka naspram kategorijskih


### univName i admit


```{r}

plt1 <- ggplot(data = novi_univerziteti)+ geom_bar(mapping = aes(x = admit, fill = univName), position = "dodge")
plt1

plt2 <- ggplot(data = novi_univerziteti)+ geom_bar(mapping = aes(y = univName, fill = admit), position = "dodge")
plt2
  
```

Na osnovu grafika iznad vidimo da je najveći broj kandidata primljen na fakultete *Arizona State University* i *University of Texas Dallas*, dok najveći broj kandidata nije uspelo da se upiše na fakultetima *North Carolina State University* i *Georgia Institute of Technology*. Na drugom grafiku vidimo da je na većini fakulteta većina kandidata koji su konkurisali uspeli su i da se upišu na fakultet, ali postoji manji broj fakulteta gde je zainteresovanost bila velika i većina kandidata nije uspelo da se upisše na željeni fakultet.

### specialization i admit

```{r}

plt1 = ggplot(novi_univerziteti, aes(x = admit, group = specialization)) +
  geom_bar(aes(y = ..prop.., fill = specialization), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "specialization") +
  facet_grid(~specialization) 
plt1

plt2 = ggplot(novi_univerziteti, aes(y = specialization, group = admit)) +
  geom_bar(aes(x = ..prop.., fill = admit), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), x = ..prop..), stat = "count", vjust = -.5) +
  labs(x = "Percent", fill = "admit") +
  facet_grid(~admit) 
plt2

```

Zanimljiva stvar koju možemo primetiti jeste da đaci koji nemaju specijalizaciju su dosta više primljeni u odnosu na druge đake koji su specijalizovani u neku posebnu oblast.


### major i admit

```{r}

plt1 = ggplot(novi_univerziteti, aes(x = admit, group = major)) +
  geom_bar(aes(y = ..prop.., fill = major), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "major") +
  facet_grid(~major) 
plt1

plt2 = ggplot(novi_univerziteti, aes(y = major, group = admit)) +
  geom_bar(aes(x = ..prop.., fill = admit), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), x = ..prop..), stat = "count", vjust = -.5) +
  labs(x = "Percent", fill = "admit") +
  facet_grid(~admit) 
plt2

```

Na grafiku vidimo da je najviše osoba bilo zainteresovano za smer *Computer Science* što je i logično jer se povećava potreba za upotrebom novih tehnologija i tržište rada je veoma veliko za buduće studente. Zbog velike zaintereseovanosti za oblast *Computer Science* većina kandidata nisu uspeli da upadnu na fakultet i za sva zanimanja vezana za računare većina kandidata nije uspela da upiše željeni fakultet. Kandidati koji su konkurisali za smer *MIS*(Management Information Systems), *Industrial Engineering* i kandidati sa ostalih smerova, većina njih je upisala željeni fakultet.

### industryExp i admit

```{r}


plt1 = ggplot(novi_univerziteti, aes(x = admit, group = industryExp)) +
  geom_bar(aes(y = ..prop.., fill = industryExp), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "industryExp") +
  facet_grid(~industryExp) 
plt1

plt2 = ggplot(novi_univerziteti, aes(x = industryExp, group = admit)) +
  geom_bar(aes(y = ..prop.., fill = admit), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "admit") +
  facet_grid(~admit) 
plt2

```

### ResearchExp i admit

```{r}

plt1 = ggplot(novi_univerziteti, aes(x = admit, group = researchExp)) +
  geom_bar(aes(y = ..prop.., fill = researchExp), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "researchExp") +
  facet_grid(~researchExp) 
plt1

plt2 = ggplot(novi_univerziteti, aes(x = researchExp, group = admit)) +
  geom_bar(aes(y = ..prop.., fill = admit), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "admit") +
  facet_grid(~admit) 
plt2

```

### internExp i admit

```{r}

plt1 = ggplot(novi_univerziteti, aes(x = admit, group = internExp)) +
  geom_bar(aes(y = ..prop.., fill = internExp), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "internExp") +
  facet_grid(~internExp) 
plt1

plt2 = ggplot(novi_univerziteti, aes(x = internExp, group = admit)) +
  geom_bar(aes(y = ..prop.., fill = admit), stat = "count") +
  geom_text(aes(label = scales::percent(..prop..), y = ..prop..), stat = "count", vjust = -.5) +
  labs(y = "Percent", fill = "admit") +
  facet_grid(~admit) 
plt2

```

Na osnovu prethodnih grafika vidimo da većina kandidata koji su imali bilo kakvo iskustvo nisu uspeli da upadnu na fakultet, dok je većina kandidata bez bilo kakvog iskustva uspela da upadne na fakultet i time zaključujemo da iskustvo kandidata nije bitno pri upisu fakulteta.


# Podela na trening i test skupove

Delimo podatke na *Train* i *Test* kao pripremu za klasifikacione modele. U ovom slučaju će *Train* podataka bili 75% iz čitavog skupa.

```{r}
smp_siz = floor(0.75*nrow(novi_univerziteti))
smp_siz

set.seed(123) 
# na slucajan nacin uzimamo uzorak 75% rednih brojeva redova 
train_ind = sample(seq_len(nrow(novi_univerziteti)),size = smp_siz) 
# kreiramo train sa rednim brojevima smestenim u train_ind
train = novi_univerziteti[train_ind,] 
# kreiramo test sa preostalim podacima
test = novi_univerziteti[-train_ind,]
```

# Stablo odlučivanja

Stablo odlučivanja je dijagram oblika stabla koji se koristi za utvrđivanje toka akcija u procesu odlučivanja. Svaka grana predstavlja moguće odluke, pojave ili reakcije. Stabla odlučivanja su najjednostavniji mehanizam za klasifikaciju i regresiju. Na osnovu stabla odlučivanja mogu se generisati pravila, koja ljudi mogu da razumeju i koja mogu biti upotrebljena za formiranje baze znanja.

## Kreiranje modela

```{r}
tree_model = rpart(admit ~ ., data=subset(train,select=c(admit, greQ, greV, greA,toeflScore, internExp, industryExp, researchExp)),method="class")

rpart.plot(tree_model)

```


```{r}
printcp(tree_model)
```


Možemo primetiti da je naš kreirani model koristio samo 2 obeležja pri konstrukciji stabla odlučivanja, u pitanju su obeležja **greQ** i **industryExp** .
Vidimo da je greška osnovnog čvora velika, malo ispod 50%, kao i rel *error* i *xerror* greske.


```{r}

predTree = predict(tree_model,test, type="class")

conf = table(predTree, test$admit, dnn =c("Prediction","Action"))

conf

```

## Metrike


Metrike koje ćemo pratiti u narednom radu jesu metrike preciznosti, odziva, kao i F1 score koja nam ujedno pokazuje više različitih metrika.


Preciznost:

```{r}
(precision = diag(conf) / sum(conf))
```
Odziv:

```{r}
(recall = (diag(conf) / colSums(conf)))
```
F1 score:

```{r}
(F1 = 2*precision*recall/(precision+recall))
```


Preciznost u odnosu na celo obeležje.

```{r}
sum(diag(conf)) / sum(conf)
```
Kao što možemo videti, preciznost nije na zadovoljavajućem nivou.

# Random Forest


  *Random forest* je metoda mašinskog učenja za klasifikaciju, regresiju ili druge modele tako što za vreme obuke konstruiše mnoštvo stabala odlučivanja. Za izlaznu vrednost modela klasifikacije random forest bira klasu koja je izabrana od vecine stabala.Za izlaznu vrednost regresionog modela vraća medijanu ili srednju vrednost predikcija svih stabala.
  Da bismo kreirali model potrebno da je sva kategorijska obeležja imaju najviše 53 različite kategorije, ali naše kategorijsko obeležje *univName* koje je veoma bitno za naše modele na osnovu detaljne prethodne analize ima 54 različite kategorije, tako da smo rešili da izbacimo jednu kategoriju koja se najmanje pojavljuje. Zbog velikog broja podataka u datom skupu neće biti problem ako uklonimo sve redove koji sadrže ovu kategoriju, pogotovo kada uzmemo u obzir da nekoliko kategorija imaju nesto manje i od 100 uzoraka, što predstavlja dosta manje od 1% ukupnog broja uzoraka.
  
Ponovno ćemo podeliti ceo okvir podataka na train i test, po istom *set.seed-u* da bismo bili sigurni da da ćemo dobiti iste rezultate za randomizaciju, ali ovog puta samo bez uzoraka koji predstavljaju kategoriju sa najmanje uzoraka, a u pitanju je univerzizet **California Institute of Technology**.

  
```{r}
xtabs(~novi_univerziteti$univName)

novi_univerziteti = novi_univerziteti[novi_univerziteti$univName != "California Institute of Technology",]

smp_siz = floor(0.75*nrow(novi_univerziteti))
smp_siz

set.seed(123) 
# na slucajan nacin uzimamo uzorak 75% rednih brojeva redova 
train_ind = sample(seq_len(nrow(novi_univerziteti)),size = smp_siz) 
# kreiramo train sa rednim brojevima smestenim u train_ind
train = novi_univerziteti[train_ind,] 
# kreiramo test sa preostalim podacima
test = novi_univerziteti[-train_ind,]
```

Nakon što smo izbrisali sve uzorke te kategorije, moramo i da sklonimo samu kategoriju sa liste postojećih kategorija.

```{r}
train$univName = droplevels(train$univName)
test$univName = droplevels(test$univName)
```
## Kreiranje modela


```{r}
rf <- randomForest(admit ~ greA + greV + greQ + major + cgpa + toeflScore + univName, data = train)
rf.pred <- predict(rf,newdata = test)

rf

```

Primećujemo da je greška znatno manja i da je ovaj model znatno bolji. 

Kreiraćemo i konfuzionu matricu na osnovu testnog skupa:

```{r}

conf = table(rf.pred, test$admit, dnn =c("Prediction","Action"))

conf
```

## Metrike

Preciznost:

```{r}
(precision = diag(conf) / sum(conf))
```

Odziv:

```{r}
(recall = (diag(conf) / colSums(conf)))
```

F1 score:

```{r}
(F1 = 2*precision*recall/(precision+recall))
```

Preciznost u odnosu na celo obeležje:

```{r}
sum(diag(conf)) / sum(conf)
```

# Logistička regresija

Logistička regresija je nadgledani algoritam mašinskog učenja koji ispunjava zadatke binarne klasifikacije predviđanjem verovatnoće ishoda, događaja ili posmatranja. Model daje binarni ishod ograničen na dva moguća ishoda: da/ne, 0/1 ili tačno/netačno.

S obzirom da mi rešavamo jedan od navedenih problema, da li je đak primljen na fakultet ili nije, odnosno da li je vrednost 0 ili 1, moći ćemo da koristimo binarnu logističku regresiju za kreiranje modela.

## Kreiranje modela

```{r}
logistic_model <- glm(admit ~ univName + major + industryExp + cgpa + greV + greA + toeflScore, 
                      data = train, 
                      family = "binomial")

summary(logistic_model)
```
Koristili smo obeležja za koje smo analizom u sekciji **EDA** zaključili da postoji povezanost, i sumarizacijom kreiranog modela vidimo da većina univerziteta su itekako povezani sa obeležjem koji želimo da prediktujemo, zatim i kod obeležja major je slična situacija. Kategorija *sa iskustvom* obeležja industryExp itekako je povezana sa *admit-om*, ali i numerička obeležja cgpa, greV, greA i toeflScore.

Nakon toga ćemo iskoristi kreirani model za prediktovanje nad testnim skupom, i pošto vrednosti mogu biti decimalne i između brojeva 0 i 1, koristićemo prag od 0.5 tako da sve vrednosti manje od vrednosti 0.5 biće okarakterisane kao 0, a veće kao 1.

```{r}
predict_reg <- predict(logistic_model, 
                       test, type = "response")

predict_reg <- ifelse(predict_reg >0.5, 1, 0)
```

Zatim ćemo kreirati matricu konfuzije.

```{r}
(conf = table(test$admit, predict_reg, dnn =c("Prediction","Action")))
```
Na prvi pogled vidimo da su rezultati sasvim solidni, ali to ćemo tačnije utvrditi metrikama.

## Metrike

Preciznost:

```{r}
(precision = diag(conf) / sum(conf))
```

Odziv:

```{r}
(recall = (diag(conf) / colSums(conf)))
```

F1 score:

```{r}
(F1 = 2*precision*recall/(precision+recall))
```


Preciznost u odnosu na celo obeležje:

```{r}
sum(diag(conf)) / sum(conf)
```

# Zaključak

Stablo odluke kreira loše modele sa velikim greškama, i zbog toga se treba izbegavati pri kreiranju modela. Metoda Random Forest najbolje opisuje podatke, međutim potrebno je previše vremena za kreiranje modela zato što Random Forest pri kreiranju najboljeg mogućeg modela kreira 500 različitih stabala, i zbog toga je sam proces veoma dug. Logistička regresija u odnosu na stablo odluke daje znatno bolje rezultate, i kada je potreba brzina za kreiranje modela, logistička regresija itekako može dobro poslužiti. Može se reći kada se uporedi odnos brzine i kvaliteta, logistička regresija daje najbolje rezultate, tako da na osnovu potreba, može se birati neki od ova 2 načina.

Smatramo da smo ovim dokumentom ispunili 3 glavna cilja kojim smo se vodili kreiranjem dokumenta, a to su: 

1. Da se izvrši adekvatan opis obeležja, i detaljna analiza uticaja/veza/zavisnosti između obeležja i u skupu podataka
2. Da se na principijalan način izvrši formiranje, odabir i tumačenje najadekvatnijeg modela mašinskog učenja za predviđanje prijema studenata na fakultetima u SAD-a.
3. Da se sirovi skup podataka dovede do nivoa kvaliteta koji omogućava dovoljno pouzdano statističko zaključivanje o vezama između obeležja. kao i formiranje adekvatnih modela mašinskog učenja za predviđanje prijema studenata na fakultetima u SAD-a.



